<!DOCTYPE html>
<html lang="en">

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">    
</head>

<body>
<canvas id="gameCanvas" width=800 height="600"></canvas>

<script>
    var canvas;
    var canvasContext;

    var rect;
    var root;

    var mouseX;
    var mouseY;

    var mouseLastX;
    var mouseSpeedX;
    
    var FPS = 30;

    var isGameStarted = false;

    // Parameters relative to position of objects 
    // in the circular playfield 
    const DIST_TO_CENTER_OFFSET = 10;
    var distToPlayfieldCenterMax;

    // Paddle variables
    const PADDLE_HEIGHT = 10;
    const PADDLE_WIDTH = 100;


    var paddleX = 0;
    var paddleAngle = 0;

    // Ball Variables
    const BALL_RADIUS = 10;

    var ballX;
    var ballY;

    var ballSpeedInit;
    var ballSpeedX;
    var ballSpeedY;

    window.onload = function(){

        startAll();

        setInterval(updateAll, 1000/FPS);

        canvas.addEventListener(
            "mousemove", function(evt) {
                getMousePosition(evt);
            }
        )

        canvas.addEventListener(
            "mousedown", function(evt) {
                if (!isGameStarted) {
                    isGameStarted = true;
                }
            }
        )
    }

    function startAll() {
        console.log("Start");
        canvas = document.getElementById("gameCanvas");
        canvasContext = canvas.getContext("2d");
        rect = canvas.getBoundingClientRect() ;
        root = document.documentElement;

        mouseLastX = 0;
        mouseX = 0;
        mouseSpeedX = 0;

        distToPlayfieldCenterMax = canvas.height/2 - DIST_TO_CENTER_OFFSET

        paddleAngle = 0;

        ballX = canvas.width/2;
        ballY = distToPlayfieldCenterMax;

        ballSpeedInit = 10;
        ballSpeedX = 10;
        ballSpeedY = 10;

        isGameStarted = false
    } 

    function updateAll() {
        drawEverything();
        moveEverything();
        showMousePosition("yellow");
    }

    function getMousePosition(evt){
        mouseX = evt.clientX - rect.left - root.scrollLeft;       
        mouseY = evt.clientY - rect.top - root.scrollTop;
    }

    function getMouseSpeedX() {
        mouseSpeedX = (mouseX - mouseLastX) ;//* FPS / 1000;
        mouseLastX = mouseX;
    }

    function restartGame() {
        isGameStarted = false;
    }

    /** *** Drawing functions *** **/
     
    function drawEverything () {

        // Red Background
        drawRectangle(0, 0, canvas.width, canvas.height, "purple");

        // Black Playground
        drawCircle(
            canvas.width/2, canvas.height/2,
            Math.min(canvas.width, canvas.height) / 2,"black"
        );

        // White Paddle
        drawRotatedRect(
            canvas.width/2, canvas.height/2,
            distToPlayfieldCenterMax - PADDLE_HEIGHT/ 2, // we take the distance of the center of the paddle to the center of the playfield
            PADDLE_WIDTH, PADDLE_HEIGHT, paddleAngle, "white"
        );

        // White ball
        drawCircle(
            ballX, ballY, BALL_RADIUS, "white"
        );
    }

    function drawRectangle(originLeft, originTop, width, height, color){
        canvasContext.fillStyle = color;
        canvasContext.fillRect(originLeft, originTop, width, height);
    }

    function drawCircle(centerX, centerY, radius, color) {
        canvasContext.fillStyle = color;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, 2*Math.PI, true);
        canvasContext.fill();
    }

    function drawRotatedRect(
        rotCenterX, rotCenterY, distToRotCenter, 
        width, height, angle, color
        ){
        
        // first save the untranslated/unrotated context
        canvasContext.save();

        // move the rotation point to the center of the canvas
        canvasContext.translate(rotCenterX, rotCenterY);

        // rotate the canvas context
        canvasContext.rotate(angle*Math.PI/180);

        // draw the rect on the transformed context
        // Note: after transforming [0,0] is visually [rotCenterX, rotCenterY]
        // so the rect X position needs to be offset accordingly when drawn
        drawRectangle(
            -width/2, distToRotCenter, width, height, color
        );

        // restore the context to its untranslated/unrotated state
        canvasContext.restore();
    }

    function showMousePosition(color) {
        canvasContext.fillStyle = color;
        canvasContext.fillText(
            mouseX + " , " + mouseY,
            mouseX, mouseY
        )
    }

    // Function movement functions
    function moveEverything() {
        movePaddle();
        moveBall();
        detectBallExitPlayfield();
    }

    function movePaddle() {
        getMouseSpeedX();

        paddleAngle += mouseSpeedX * (-360/400); // when the mouse moves by 400 pix, a full rotation is done
        if (!(paddleAngle % 360)){
            paddleAngle = 0;
        }
    }

    function moveBall() {
        if (isGameStarted) {
            ballX += ballSpeedX;
            ballY += ballSpeedY;
        }
        else {
            ballX = canvas.width/2 + distToPlayfieldCenterMax * Math.cos((paddleAngle+90)*Math.PI/180);
            ballY = canvas.height/2 + distToPlayfieldCenterMax * Math.sin((paddleAngle+90)*Math.PI/180);

            var speedDir = getSpeedDirection(ballX, ballY, canvas.width/2, canvas.height/2)
            ballSpeedX = ballSpeedInit * speedDir.x; //getSpeedDirection(canvas.width/2 , ballX);
            ballSpeedY = ballSpeedInit * speedDir.y; //getSpeedDirection(ballY, canvas.height/2);
        }
    }

    function getSpeedDirection(originX, originY, targetX, targetY){
        var dirX = 1;
        var dirY = 1;

        if (originX > targetX) {
            dirX = -1;
        }

        if (originY > targetY) {
            dirY= -1;
        }
        return {
            x: dirX,
            y: dirY
        };
    }

    // Collisions
    function detectBallExitPlayfield() {
        var distBallToPlayfieldCenter = distBetweenTwoPoints(
            ballX, ballY, canvas.width/2, canvas.height/2
        )

        if (distBallToPlayfieldCenter > distToPlayfieldCenterMax){
            restartGame();
        }
    }

    function distBetweenTwoPoints(point1X, point1Y, point2X, point2Y) {
        return Math.sqrt(
            (point1X - point2X) * (point1X - point2X) + (point1Y - point2Y) * (point1Y - point2Y)
        )
    }


    



</script>
</body>

</html>